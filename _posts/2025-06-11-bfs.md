---
title: BREADTH-FIRST SEARCH (BFS)
date: 2025-06-11 13.14.00 +0800
categories: [Desain dan Analisis Algoritma]
tags: [Graph, BFS, Queue, Pathfinding, Traversal]
---

# BREADTH-FIRST SEARCH (BFS) ğŸ”

Halo teman-teman pencari jalan algoritmik! ğŸ§­

Hari ini kita akan menyelami cara kerja algoritma **Breadth-First Search (BFS)** yang keren banget buat mencari **jalur tercepat** di graf atau pohon! Bayangin kamu lagi di kampus lantai 1 dan mau cari ruang kelas di lantai 3â€”pasti kamu cek semua ruangan lantai 1 dulu sebelum naik, kan? Nah, itulah semangat BFS: **jelajahi semua tetangga terdekat dulu, baru lanjut lebih jauh**.

---

## APA ITU BREADTH-FIRST SEARCH? ğŸ¤”

BFS adalah algoritma traversal graf yang menelusuri simpul-simpul berdasarkan **jaraknya dari simpul awal**. Artinya, BFS akan menjelajahi semua simpul pada level yang sama sebelum naik ke level berikutnya.

BFS cocok digunakan untuk:
- Menemukan **jalur terpendek**
- Menelusuri jaringan sosial
- Navigasi (seperti di Google Maps!)
- Analisis jaringan komputer

---

## STRUKTUR UTAMA: QUEUE! ğŸ“¦

BFS menggunakan **queue (antrian)** untuk menyimpan simpul yang akan dikunjungi.

Langkah-langkah:
1. Masukkan simpul awal ke dalam queue
2. Ambil simpul dari antrian â†’ tandai sebagai dikunjungi
3. Masukkan semua tetangga simpul tersebut ke queue
4. Ulangi sampai queue kosong atau simpul tujuan ditemukan

---

## ILUSTRASI KERJA BFS ğŸ”„

Graf sederhana:
```
     S
    / \
   A   B
  / \ / \
 C  D E  F
       / \
      H   G
```

Simulasi Queue dan Visited:
```
Queue    : S â†’ A,B â†’ B,C,D â†’ C,D,E,F â†’ D,E,F â†’ E,F â†’ F,H,G â†’ H,G â†’ G
Visited  : S â†’ SA â†’ SAB â†’ SABC â†’ SABCD â†’ SABCDE â†’ SABCDEF â†’ SABCDEFH â†’ SABCDEFHG
```

---

## IMPLEMENTASI C++ ğŸ’»

```cpp
#include <iostream>
#include <queue>
#include <vector>
using namespace std;

void bfs(int start, vector<vector<int>>& adj, int n) {
    vector<bool> visited(n, false);
    queue<int> q;

    visited[start] = true;
    q.push(start);

    while (!q.empty()) {
        int node = q.front(); q.pop();
        cout << node << " ";

        for (int neighbor : adj[node]) {
            if (!visited[neighbor]) {
                visited[neighbor] = true;
                q.push(neighbor);
            }
        }
    }
}

int main() {
    int n = 7;
    vector<vector<int>> adj(n);
    // Menambahkan edge untuk graf undirected
    adj[0] = {1, 2}; // S
    adj[1] = {0, 3, 4}; // A
    adj[2] = {0, 5, 6}; // B
    adj[3] = {1}; // C
    adj[4] = {1}; // D
    adj[5] = {2}; // E
    adj[6] = {2}; // F

    bfs(0, adj, n);
    return 0;
}
```

---

## APLIKASI NYATA BFS ğŸŒ

1. **Navigasi & Transportasi** ğŸš—  
   BFS dipakai Google Maps, Grab, Gojek untuk cari **rute terpendek** dengan asumsi semua jalan setara.

2. **Game & AI** ğŸ®  
   Game seperti Pac-Man memakai BFS untuk mengejar pemain secara optimal.

3. **Media Sosial** ğŸŒ  
   Menemukan koneksi seperti "Orang yang Mungkin Anda Kenal" â†’ BFS dari pengguna ke teman, lalu ke teman-teman mereka.

4. **Jaringan Komputer** ğŸ–§  
   BFS menjelajah router, switch, dan perangkat dalam level yang efisien.

---

## KELEBIHAN & KEKURANGAN ğŸ“Š

**Kelebihan:**
- Menjamin solusi paling optimal (jalur terpendek)
- Mudah diimplementasikan

**Kekurangan:**
- Butuh memori cukup besar
- Kurang efisien di graf sangat besar

---

## KESIMPULAN ğŸ§ 

BFS adalah algoritma yang **sederhana tapi kuat** untuk menjelajahi graf secara sistematis. Dengan pendekatan level-by-level, BFS memastikan kita menemukan solusi tercepatâ€”entah itu di game, peta, atau jejaring sosial.

Ayo terus eksplorasi graf dan algoritma lainnya! ğŸ’¡

Happy coding! ğŸ”ğŸ’»
